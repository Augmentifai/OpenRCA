import sys
import os
import re

parent_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), os.pardir))
sys.path.insert(0, parent_dir)


system = """Let's play a game. In this game, your task is to check whether the response from the DevOps assistant system meets each scoring criterion. You will assign points to the response based on the given scoring criteria. Your goal is to provide a well-reasoned score that would be convincing to even the most experienced human experts. They should not be able to tell that this score was generated by an AI assistant following specific guidelines.

The information provided to you includes the following components:

```issue
(Instruction for the DevOps assistant system)
```

```prediction
(Response from the DevOps assistant system)
```

```scoring_points
(Scoring criteria for the response)
```

Your response should follow the JSON format below:

{
    "passed criteria": (A list of criteria that the response meets.),
    "failed criteria": (A list of criteria that the response does not meet.),
    "score": (The total score.)
}
(DO NOT contain "```json" and "```" tags. DO contain the JSON object with the brackets "{}" only.)

**RULES OF SCORING POINTS**:

1. A prediction is considered correct if the predicted root cause occurrence datetime is within 1 minutes (i.e., <=1min) of the reference root cause occurrence datetime. For example, if the reference datetime is `2022-03-20 09:09:06` and the predicted time is `2022-03-20 09:09:00`, the prediction is correct.

2. A prediction is incorrect (score=0.0) if it states there is no fault or does not provide information about the failure root cause, when the reference indicates a failure exists. For example, if the prediction is “I cannot find any failure or root cause,” it is incorrect, and you should assign a score of 0.0, regardless of other criteria.

Now, let's get started!"""

user = """Please evaluate the response from the DevOps assistant system based on the scoring points provided. Assign points to the response based on the scoring criteria. If the response meets the criteria, assign the corresponding points. If the response does not meet the criteria, assign 0 points:

```issue
{issue}
```

```prediction
{prediction}
```

```scoring_points
{scoring_points}
```"""

def evaluate(prediction:str, scoring_points:str):

    import itertools

    predict_pattern = (
        r'{\s*'
        r'(?:"root cause occurrence datetime":\s*"(.*?)")?,?\s*'
        r'(?:"root cause component":\s*"(.*?)")?,?\s*'
        r'(?:"root cause reason":\s*"(.*?)")?\s*}'
    )

    predict_matches = re.findall(predict_pattern, prediction)


    predict_results = []
    
    for match in predict_matches:
        datetime_str, component, reason = match
        predict_results.append({
            "root cause occurrence datetime": datetime_str,
            "root cause component": component,
            "root cause reason": reason
        })



    prediction_length = len(predict_results)

    component_pattern = r"The (?:\d+-th|only) predicted root cause component is ([^.]+)"
    reason_pattern = r"The (?:\d+-th|only) predicted root cause reason is ([^.]+)"
    time_pattern = r"The (?:\d+-th|only) root cause occurrence time is within 1 minutes \(i.e., <=1min\) of (.*?)\s*\(?1 point\)?"

    components = re.findall(component_pattern, scoring_points)
    reasons = re.findall(reason_pattern, scoring_points)
    times = re.findall(time_pattern, scoring_points)

    scoringpoints_length = max(len(components),len(reasons),len(times))
    socres_num = len(components)+len(reasons)+len(times)

    def time_difference(time1_str,time2_str):
        from datetime import datetime
        time_format = "%Y-%m-%d %H:%M:%S"
        
        try:
            time1 = datetime.strptime(time1_str, time_format)
            time2 = datetime.strptime(time2_str, time_format)
        except ValueError:
            return False
        
        time_difference = abs(time1 - time2)
        if time_difference.total_seconds() <= 60:
            return True
        else:
            return False

    scores_get = 0
    passing_criteria = []
    failing_criteria = []

    if scoringpoints_length == prediction_length:  
        best_sore = -1
        for perm in itertools.permutations(predict_results):
            current_score = 0
            current_passing = []
            for i in range(scoringpoints_length):
                if len(components) == scoringpoints_length:
                    if perm[i]['root cause component'] == components[i]:
                        current_score +=1
                        current_passing.append(components[i])
                if len(reasons) == scoringpoints_length:
                    if perm[i]['root cause reason'] == reasons[i]:
                        current_score +=1
                        current_passing.append(reasons[i])
                if len(times) == scoringpoints_length:
                    if time_difference(times[i],perm[i]['root cause occurrence datetime']):
                        current_score +=1
                        current_passing.append(times[i])
            if current_score>best_sore:
                best_sore = current_score
                passing_criteria = current_passing
        scores_get = best_sore            
    
    failing_criteria = list(set(components+reasons+times)-set(passing_criteria))
    
    final_score = scores_get/socres_num
    bin_score = round(final_score,2)
    return passing_criteria, failing_criteria, bin_score
 