import pandas as pd
from datetime import datetime, timedelta
import random
import json
import pytz
import sys
import os

parent_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), os.pardir))
sys.path.insert(0, parent_dir)

from utils import get_chat_completion

random.seed(42)

system = """Let's play a game. In this game, your task is to generate a issue related to DevOps failure diagnosis based on a given set of specifications. The goal is to make the issue realistic enough that even top human experts might believe it reflects a genuine issue an engineer could encounter at work. They should not be able to tell that the issue was generated by an AI Assistant based on specifications.

The specifications provided to you include the following components:

```known
(The known information explicitly provided in the issue.)
```

```query
(The target query that required the user to answer.)
```

Your response should follow the JSON format below:

{
    "issue": (Your generated issue based on the specifications.)
}
(DO NOT contain "```json" and "```" tags. DO contain the JSON object with the brackets "{}" only.)

For example, if the following specifications are given:
 
```known
- number of failures: 1
- time range: 2022-03-21 11:30:00 to 2022-03-21 12:00:00
- system: None
```

```query
- root cause occurrence time: **UNKNOWN**
```

Then, you could generate a issue be like:

{
    "issue": "During the specified time range of March 21, 2022, from 11:30 to 12:00, the cloud service system experience a failure. The exact time of the root cause occurrence is unknown, which complicates the diagnosis process. Please pinpoint the root cause occurrence datetime."
}

There is another example: 

```known
- number of failures: 2
- time range: 2022-03-20 09:30:00 to 2022-03-20 10:00:00
- system: cloudbed-1
```

```query
- root cause occurrence time: **UNKNOWN**
- root cause component: **UNKNOWN**
- root cause reason: **UNKNOWN**
```

The generated issue be like:

{
    "issue": "The cloud service system, cloudbed-1, may have experienced two failures within the time range of March 20, 2022, from 09:30 to 10:00. The exact number of failures, the time of occurrence, the affected components, and the underlying reasons for these failures are currently unknown. You are tasked with identifying the root cause occurrence datetime, the root cause component, and the root cause reason."
}

Some rules to follow:

1. Do not tell the user "how to solve the issue" (e.g., retrieve the telemetry data like metrics/logs/traces).
2. Do not involve human interaction in the issue (e.g., "ask the engineer for more information").
3. Do not include any specific values that are not mentioned in the specification (e.g., "the CPU usage was 80%").

Now, let's get started!"""

user = """Please generate a issue related to DevOps failure diagnosis based on the following specifications:

```known
{input_specification}
```

```query
{output_specification}
```"""

timezone = pytz.timezone('Asia/Shanghai')

def timestamp2timeperiod(timestamp) -> str:
    time = datetime.fromtimestamp(timestamp, timezone)
    minute = time.minute
    start_time = time.replace(minute=minute - (minute % 30), second=0, microsecond=0)
    end_time = start_time + timedelta(minutes=30)
    start_time_str = start_time.strftime('%Y-%m-%d %H:%M:%S')
    end_time_str = end_time.strftime('%Y-%m-%d %H:%M:%S')
    return f"{start_time_str} to {end_time_str}"

def timestamp2shortperiod(timestamp):
    time = datetime.fromtimestamp(timestamp, timezone)
    second = time.second
    if second <= 30:
        time = time - timedelta(seconds=second)
    else:
        time = time + timedelta(seconds=60 - second)
    
    start_time = time - timedelta(minutes=1)
    end_time = time + timedelta(minutes=1)
    start_time_str = start_time.strftime('%Y-%m-%d %H:%M:%S')
    end_time_str = end_time.strftime('%Y-%m-%d %H:%M:%S')
    return f"{start_time_str} to {end_time_str}"

def timestamp2datetime(timestamp: int) -> str:
    time = datetime.fromtimestamp(timestamp, timezone)
    utc_plus_8_time = time.strftime('%Y-%m-%d %H:%M:%S')
    return utc_plus_8_time

def get_half_hour_conflict_failure_flag(meta_data):
    sorted_time = sorted(meta_data['timestamp'])
    half_hour_conflict_failure_flag = {}
    previous_failure_timestamp = 0
    for i in range(len(sorted_time)): 
        timestamp = sorted_time[i]   
        current_failure_timestamp_left = timestamp // 1800
        if current_failure_timestamp_left > previous_failure_timestamp:
            previous_failure_timestamp = current_failure_timestamp_left
            half_hour_conflict_failure_flag[timestamp] = False
        else:
            half_hour_conflict_failure_flag[timestamp] = True
            half_hour_conflict_failure_flag[sorted_time[i - 1]] = True 
    return half_hour_conflict_failure_flag

def get_multi_response_dict(row, meta_data, task_specs):
    num = 0
    multi_dict = {
        "datetime": [],
        "component": [],
        "reason": [],
    }
    cand_df = meta_data[meta_data['timestamp']//1800 == row['timestamp']//1800]
    for idx, cand in cand_df.iterrows():
        num += 1
        for key in multi_dict:
            multi_dict[key].append(cand[key])

    return num, multi_dict

def generate_instructions_and_responses(gt_path, spec_path, extra_spec):

    meta_data = pd.read_csv(gt_path)
    with open(spec_path, "r", encoding="utf8") as f:
        task_templates = json.load(f)

    half_hour_conflict_failure_flag = get_half_hour_conflict_failure_flag(meta_data)

    full_task_ID_list = list(task_templates.keys())
    
    df = pd.DataFrame(columns=["task_index", "instruction", "scoring_points"])
    for idx, row in meta_data.iterrows():
        print(f"processing: {idx}")

        timestamp = row['timestamp']
        reason = row['reason']
        component = row['component']
        datetime = timestamp2datetime(timestamp)
        time_period = timestamp2timeperiod(timestamp)

        task_index = random.choice(full_task_ID_list)

        if half_hour_conflict_failure_flag[timestamp]:
            num, ans = get_multi_response_dict(row, meta_data, task_templates[task_index])
            scoring_points = ""
            for i in range(num):
                scoring_points_template = task_templates[task_index]['scoring_points'].copy()
                scoring_points_filled = [points.format(
                    idx = f'{i+1}-th',
                    datetime = ans['datetime'][i],
                    reason = ans['reason'][i],
                    component = ans['component'][i],
                ) for points in scoring_points_template]
                scoring_points += "\n".join(scoring_points_filled)
                scoring_points += "\n"
            print(f"The {idx}-th is a multi-response task, containing {num} root cause.")
        else:
            num = 1
            scoring_points = ""
            for point in task_templates[task_index]['scoring_points']:
                scoring_points += point.format(
                    idx='only',
                    time_period=time_period,
                    datetime=datetime,
                    component=component,
                    reason=reason
                )
                scoring_points += "\n"

        input_specification = "```known\n"
        for spec in task_templates[task_index]['input']:
            input_specification += f"- "
            input_specification += spec.format(
                num=num,
                time_period=time_period
            )
            input_specification += "\n"
        if extra_spec:
            input_specification += f"- {extra_spec}\n"
        input_specification = input_specification.strip() + "\n```"

        output_specification = "```query\n"
        for spec in task_templates[task_index]['output']:
            output_specification += f"- "
            output_specification += spec.format(
                time_period="**UNKNOWN**",
                datetime="**UNKNOWN**",
                component="**UNKNOWN**",
                reason="**UNKNOWN**",
            )
            output_specification += "\n"
        output_specification = output_specification.strip() + "\n```"

        prompt = [
                {'role': 'system', 'content': system},
                {'role': 'user', 'content': user.format(input_specification=input_specification, 
                                                        output_specification=output_specification)},
            ]
        
        print(scoring_points)
        
        for i in range(3):
            try:
                instruction = get_chat_completion(
                    messages=prompt,
                    ground=True,
                    temperature=1.0
                )
                instruction = instruction
                instruction = json.loads(instruction)['issue']
                break
            except Exception as e:
                print(e)
                continue
        
        new_df = pd.DataFrame([{"task_index": task_index,
                                "instruction": instruction,
                                "scoring_points": scoring_points}])
        df = pd.concat([df, new_df], 
                       ignore_index=True)
        
        df.to_csv(gt_path.replace("groundtruth", "instruction"), index=False)
        print(f"genereated: {task_index}")

template = """\t"{idx}": {{
        "root cause occurrence datetime": {datetime},
        "root cause component": {component},
        "root cause reason": {reason},
    }},\n"""

key_field = ["root cause occurrence datetime", "root cause component", "root cause reason"]

def generate_instructions_and_responses_for_training(gt_path, spec_path, extra_spec):

    meta_data = pd.read_csv(gt_path)
    with open(spec_path, "r", encoding="utf8") as f:
        task_templates = json.load(f)

    half_hour_conflict_failure_flag = get_half_hour_conflict_failure_flag(meta_data)

    full_task_ID_list = list(task_templates.keys())
    
    df = pd.read_csv(gt_path.replace("train-gt", "train-ins"))
    for idx, row in meta_data.iterrows():
        print(f"processing: {idx}")

        timestamp = row['timestamp']
        reason = row['reason']
        component = row['component']
        datetime = timestamp2datetime(timestamp)
        time_period = timestamp2timeperiod(timestamp)

        task_index = random.choice(full_task_ID_list)

        if half_hour_conflict_failure_flag[timestamp]:
            num, ans = get_multi_response_dict(row, meta_data, task_templates[task_index])
            scoring_points = ""
            for i in range(num):
                scoring_points += template.format(
                    idx = f'{str(i+1)}',
                    datetime = ans['datetime'][i],
                    reason = ans['reason'][i],
                    component = ans['component'][i],
                )
            print(f"The {idx}-th is a multi-response task, containing {num} root cause.")
        else:
            num = 1
            scoring_points = ""

            scoring_points += template.format(
                idx='1',
                datetime=datetime,
                component=component,
                reason=reason,
            )

        scoring_points = scoring_points.split("\n")
        scoring_points = [point for point in scoring_points if point.split(":")[0].strip()[1:-1] in key_field and point.split(":")[0].strip()[1:-1] in '\n'.join(task_templates[task_index]['output']) or point.split(":")[0].strip()[1:-1] not in key_field]
        scoring_points = "\n".join(scoring_points)

        scoring_points = scoring_points[:-1]
        scoring_points = "{\n" + scoring_points + "\n}"

        df.loc[idx, "scoring_points"] = scoring_points
        df.to_csv(gt_path.replace("train-gt", "train-ins"), index=False)


if __name__ == "__main__":
    spec_path = 'bench/task_specification.json'
    gt_path_list = [
        'bench/groundtruth/Market-cloudbed-1.csv',
        'bench/groundtruth/Market-cloudbed-2.csv',
        'bench/groundtruth/Bank.csv',
        'bench/groundtruth/Telecom.csv',
    ]
    extra_spec_list = [
        "system: cloudbed-1",
        "system: cloudbed-2",
        None,
        None,
    ]
    data_list = list(zip(gt_path_list, extra_spec_list))

    for gt_path, extra_spec in data_list:
        print("processing: ", gt_path)
        generate_instructions_and_responses(gt_path, spec_path, extra_spec)